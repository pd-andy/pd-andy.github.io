{"version":3,"sources":["js/elmPromisify.js","js/mostInViewport.js","js/scrollTo.js","main.js"],"names":["Elm","node","flags","app","init","Promise","resolve","window","requestAnimationFrame","lastFocusedSection","e","sections","focusedSection","Array","from","target","children","map","section","bounding","getBoundingClientRect","y","Math","abs","id","inViewport","innerHeight","height","filter","sort","a","b","shift","document","querySelector","scrollIntoView","behavior","history","pushState","Main","then","ports","scrollToElement","subscribe","addEventListener","focusedElement","onFocusChange","send"],"mappings":";;;AAQC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EARc,IAAA,EAAA,SAACA,EAAyB,GAAlBC,IAAAA,EAAAA,EAAAA,KAAMC,EAAAA,EAAAA,MACrBC,EAAMH,EAAII,KAAK,CAAEH,KAAAA,EAAMC,MAAAA,IAEtB,OAAA,IAAIG,QAAQ,SAAAC,GACjBC,OAAOC,sBAAsB,WAC3BF,EAAQH,QAGb,QAAA,QAAA;;AC0BA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EA/BD,IAAIM,EAAqB,GAEV,EAAA,SAAAC,GAGPC,IAiBAC,EAjBWC,MAAMC,KAAKJ,EAAEK,OAAOC,UAElCC,IAAI,SAAAC,GACGC,IAAAA,EAAWD,EAAQE,wBAElB,MAAA,CACLC,EAAGC,KAAKC,IAAIJ,EAASE,GACrBG,GAAIN,EAAQM,GACZC,WAAYN,EAASE,EAAId,OAAOmB,aAAeP,EAASE,GAAKd,OAAOmB,YAAcP,EAASQ,UAI9FC,OAAO,SAAAV,GAAWA,OAAAA,EAAQO,aAG1BI,KAAK,SAACC,EAAGC,GAAMD,OAAAA,EAAET,EAAIU,EAAEV,IAEMW,QAE5BpB,OAAAA,EAAeY,KAAOf,GACxBA,EAAqBG,EAAeY,GAC7BZ,EAAeY,KAEtBf,EAAqBG,EAAeY,GAC7B,OAEV,QAAA,QAAA;;AC7BA,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EALc,IAAA,EAAA,SAAAA,GACbS,SAASC,cAAkBV,IAAAA,OAAAA,IAAMW,eAAe,CAC9CC,SAAU,WAEZ7B,OAAO8B,QAAQC,UAAU,KAAM,KAAUd,IAAAA,OAAAA,KAC1C,QAAA,QAAA;;ACKD,aAVA,IAAA,EAAA,QAAA,kBACA,EAAA,EAAA,QAAA,sBACA,EAAA,EAAA,QAAA,wBACA,EAAA,EAAA,QAAA,kBAOA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GALA,IAAMvB,EAAOgC,SAASC,cAAc,kBAC9BhC,EAAQ,IAId,EAAaF,EAAAA,SAAAA,EAAIuC,IAAAA,KAAM,CAAEtC,KAAAA,EAAMC,MAAAA,IAASsC,KAAK,SAAArC,GAE3CA,EAAIsC,MAAMC,gBAAgBC,UAAUR,EAApC,SAGAF,SAASC,cAAc,QAAQU,iBAAiB,SAAU,SAAAlC,GAClDmC,IAAAA,GAAiB,EAAenC,EAAAA,SAAAA,GAElCmC,IACF1C,EAAIsC,MAAMK,cAAcC,KAAKF,GAC7BtC,OAAO8B,QAAQC,UAAU,KAAM,KAAUO,IAAAA,OAAAA","file":"main.9df44829.js","sourceRoot":"../src","sourcesContent":["export default (Elm, { node, flags }) => {\n  const app = Elm.init({ node, flags })\n\n  return new Promise(resolve => {\n    window.requestAnimationFrame(() => {\n      resolve(app)\n    })\n  })\n}\n","// We keep track of the last focused section so that we only send updates to\n// the elm app when things change. This prevents us from blasting elm with\n// data every time we scroll.\nlet lastFocusedSection = ''\n\nexport default e => {\n  // Get all of this element's children and work out which ones are currently\n  // visible in the viewport.\n  const sections = Array.from(e.target.children)\n    // Map each element to an object with only the useful information in it.\n    .map(section => {\n      const bounding = section.getBoundingClientRect()\n\n      return {\n        y: Math.abs(bounding.y),\n        id: section.id,\n        inViewport: bounding.y < window.innerHeight && bounding.y > -window.innerHeight - bounding.height\n      }\n    })\n    // Filter out all the elements that aren't currently visible in the viewport.\n    .filter(section => section.inViewport)\n    // Sort the array so that the most prominent section is the first item in\n    // the array.\n    .sort((a, b) => a.y - b.y)\n  //\n  const focusedSection = sections.shift()\n\n  if (focusedSection.id !== lastFocusedSection) {\n    lastFocusedSection = focusedSection.id\n    return focusedSection.id\n  } else {\n    lastFocusedSection = focusedSection.id\n    return null\n  }\n}\n","export default id => {\n  document.querySelector(`#${id}`).scrollIntoView({\n    behavior: 'smooth'\n  })\n  window.history.pushState(null, null, `#${id}`)\n}\n","import { Elm } from './elm/Main.elm'\nimport elmPromisify from './js/elmPromisify'\nimport mostInViewport from './js/mostInViewport'\nimport scrollIntoView from './js/scrollTo'\n\nconst node = document.querySelector('#elm-container')\nconst flags = {}\n\n// elmPromisify resolves an elm app after the next animation frame, guaranteeing\n// the elm app gets a chance to render at least once.\nelmPromisify(Elm.Main, { node, flags }).then(app => {\n  // elm -> js ports\n  app.ports.scrollToElement.subscribe(scrollIntoView)\n\n  // js -> elm ports\n  document.querySelector('main').addEventListener('scroll', e => {\n    const focusedElement = mostInViewport(e)\n\n    if (focusedElement) {\n      app.ports.onFocusChange.send(focusedElement)\n      window.history.pushState(null, null, `#${focusedElement}`)\n    }\n  })\n})\n"]}